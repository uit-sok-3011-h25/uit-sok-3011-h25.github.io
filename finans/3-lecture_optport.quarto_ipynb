{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"3 - Matrices, Optimal Portfolios\"\n",
        "author: \"Espen Sirnes\"\n",
        "date: \"2025-8-10\"\n",
        "---\n",
        "\n",
        "This lecture explores the strategic behavior of an investor in the stock market, particularly under the assumption of risk aversion, as discussed in the previous note on utility theory. Risk lovers generally prefer the most risky assets, while risk-neutral investors opt for assets with the highest returns. In contrast, a risk-averse investor seeks to maximize returns without disproportionately increasing volatility, typically measured as variance.\n",
        "\n",
        "\n",
        "\n",
        "# Matrices\n",
        "\n",
        "To calculate optimal portfolios for any number of assets, a basic understanding of matrix algebra [@Cayley1858] is essential. Matrix algebra simplifies the resolution of several equations simultaneously, a process that becomes increasingly complex with the addition of variables. Using matrix functions in software like Excel and various statistical packages allows us to solve systems of equations efficiently without manually computing each one.\n",
        "\n",
        "Matrices not only streamline the computation but also simplify notation, making the formulation of equations for optimal portfolios more manageable.\n",
        "\n",
        "A matrix is a structured array of numbers arranged in rows and columns, essentially a set of vectors. Here's an example of a vector:"
      ],
      "id": "75215cda"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "np.random.randint(0,100,3)"
      ],
      "id": "3a49fb1d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Combining several vectors side-by-side forms a matrix:"
      ],
      "id": "02ce7771"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "np.random.randint(0,100,(2,3))"
      ],
      "id": "0c0b219c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This format is sometimes denoted as $\\mathbf{X}_{N \\times K}$ to indicate the number of rows ($N$) and columns ($K$).\n",
        "\n",
        "# Algebra with Matrices\n",
        "\n",
        "Matrix algebra operates under similar principles to ordinary algebra—allowing addition, subtraction, multiplication, and division (through inversion)—but it also requires adherence to specific rules.\n",
        "\n",
        "## Matrix Multiplication\n",
        "\n",
        "The core operation in matrix algebra is matrix multiplication, which combines elements from the rows of the first matrix with the columns of the second. For example, multiplying a $2 \\times 3$ matrix by a $3 \\times 2$ matrix yields:"
      ],
      "id": "57df996c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X = np.random.randint(0,5,(2,3))\n",
        "Y = np.random.randint(0,5,(3,2))\n",
        "result = X @ Y\n",
        "print(X)\n",
        "print(Y)\n",
        "print(result)"
      ],
      "id": "b81f2d56",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "What happens is that we sum the product of the elements in each row of the first matrix and each column of the second. You can for example check that element [0,0] of the result is the sum of the product of the first row of the first matrix, and the first column of the second. An easy way to remember this is to think of the multiplication of $A \\times B$ is to follow the lines of the letters:\n",
        "![multiplication rule](img/multrule.png \"Muliplication rule\")\n",
        "\n",
        "Due to the rules for matrix multiplication, it requires the number of columns in the first matrix to match the number of rows in the second.\n",
        "\n",
        "The matrix multiplication is different from the normal multiplication in Python. Normal multiplicaiton can be done with the normal multiplication operator `*`. It will then multiply each element in X with the corresponding element of Y, and both matrices must be of the same size:"
      ],
      "id": "48b37918"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X = np.random.randint(0,5,(2,3))\n",
        "Y = np.random.randint(0,5,(2,3))\n",
        "result = X*Y\n",
        "print(X)\n",
        "print(Y)\n",
        "print(result)"
      ],
      "id": "af57cde0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The reason for using the former method, is that the former is required for solving sets of equations. \n",
        "\n",
        "## Adding and Subtracting Matrices\n",
        "\n",
        "Adding or subtracting matrices is straightforward; simply add or subtract corresponding elements. In Python, the multiplication requires  numpy function, but if the matrices are numpy variables, subtraction and addition can be done with the normal operators. "
      ],
      "id": "dc98bc57"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "X = np.random.randint(0,100,(2,2))\n",
        "Y = np.random.randint(0,100,(2,2))\n",
        "\n",
        "# Addition of matrices\n",
        "print(f\"X:\\n{X}\")\n",
        "print(f\"Y:\\n{Y}\")\n",
        "print(f\"X+Y:\\n{X+Y}\")"
      ],
      "id": "118bb5aa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Dividing with a Matrix\n",
        "\n",
        "While direct division isn't defined in matrix operations, we can achieve a similar result by multiplying by the inverse of a matrix. The inverse of a matrix $\\mathbf{X}$, denoted $\\mathbf{X}^{-1}$, satisfies:\n",
        "\n",
        "$$\n",
        "\\mathbf{X} \\times \\mathbf{X}^{-1} = \\mathbf{I} =\n",
        "\\begin{pmatrix}\n",
        "1 & 0 & \\cdots & 0 \\\\\n",
        "0 & 1 & \\cdots & 0 \\\\\n",
        "\\vdots & \\vdots & \\ddots & \\vdots \\\\\n",
        "0 & 0 & \\cdots & 1\n",
        "\\end{pmatrix}\n",
        "$${#eq-matrix_example}\n",
        "\n",
        "where $\\mathbf{I}$ is the identity matrix. Multiplying any matrix by $\\mathbf{I}$ results in the original matrix, akin to multiplying any number by 1.\n",
        "\n",
        "In practice, while the concept is straightforward, the actual calculation of a matrix inverse can become complex for larger matrices and is typically handled by computers. We will not go through the method of obtaining the inverse in this course, we will in stead just utilize the numpy funciton for calculating the inverse. Specifically, we use `np.linalg.inv(X)`. We can check that it actually complies with the definition like this:"
      ],
      "id": "737cfed8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "X = np.random.randint(0,10,(3,3))\n",
        "# Calculating inverse of X\n",
        "X_inv = np.linalg.inv(X)\n",
        "\n",
        "# Testing\n",
        "np.round(X_inv @ X,1)"
      ],
      "id": "e3c85714",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Solving Equations with Matrix Algebra\n",
        "\n",
        "The foundation we've established for matrix algebra now allows us to efficiently solve systems of equations. Consider solving the following pair of simultaneous equations:\n",
        "\n",
        "$$\n",
        "x_{11}a_{1} + x_{12}a_{2} = b_{1} \\\\\n",
        "x_{21}a_{1} + x_{22}a_{2} = b_{2}\n",
        "$${#eq-equation_system}\n",
        "\n",
        "Here, we know the values of $x$ and $b$ but need to find the values of $a$. These equations can be succinctly expressed using matrix notation:\n",
        "\n",
        "$$\n",
        "\\mathbf{X \\times a} = \\mathbf{b}\n",
        "$${#eq-Xab}\n",
        "\n",
        "where $\\mathbf{a}$ and $\\mathbf{b}$ are column vectors. Let us define the right hand side vector `b` and the coeficient matrix `X` randomly in python as"
      ],
      "id": "d6a83757"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "b =  np.random.randint(0,100,(2,1))\n",
        "# Define matrix X\n",
        "X =  np.random.randint(0,100,(2,2))\n",
        "print(X)\n",
        "print(b)"
      ],
      "id": "2f8861bc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To solve for $\\mathbf{a}$, we use the inverse of $\\mathbf{X}$, provided it exists, and multiplies it with the left and right hand sides of the equation, just as we would divide with X on both sides to solve for a single equation:\n",
        "\n",
        "$$\n",
        "\\mathbf{X}^{-1} \\times \\mathbf{X} \\times \\mathbf{a} = \\mathbf{X}^{-1}\\mathbf{b}\n",
        "$${#eq-matrix_inverse}\n",
        "\n",
        "Since we know that $\\mathbf{X}^{-1}$ is the solution to $\\mathbf{X}^{-1} \\times \\mathbf{X} = \\mathbf{I}$, premultiplying with $\\mathbf{X}^{-1}$ yields:\n",
        "\n",
        "$$\n",
        "\\mathbf{a} = \\mathbf{X}^{-1}\\mathbf{b}\n",
        "$${#eq-matrix_inversion}\n",
        "\n",
        "Hence, we have found an easy way to solve any linear equation. We can test that it works in python. Let us first find `a` using this approach: "
      ],
      "id": "6d4ff183"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "a = np.linalg.inv(X) @ b\n",
        "a"
      ],
      "id": "f93ea4e8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "If you get a \"Singular matrix\" error its because we are generating `X` with a few random integers, which sometimes creates unsolvable systems, so just generate `X` and `b` again.\n",
        "\n",
        "Now we can test, if the solution for a actually works, by applying it on the original equation $\\mathbf{X \\times a} = \\mathbf{b}$. This should yield the right hand side of th equation, `b`:"
      ],
      "id": "b647aa61"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X @ a"
      ],
      "id": "f4ffc0a9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        " Compare this with the actual `b`:"
      ],
      "id": "f94dbc65"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "b"
      ],
      "id": "ae600cac",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Thus, we have identified an effective method to solve any system of equations, provided that $\\mathbf{X}$ is invertible. If $\\mathbf{X}$ cannot be inverted, it indicates that two or more equations are essentially identical, leading to an \"underdetermined\" system. In such cases, some equations are redundant, and there are not enough independent equations to determine the values of all variables. Remember the fundamental rule: we need an equal number of equations and unknowns to uniquely solve for each variable.\n",
        "\n",
        "\n",
        "## Transposing\n",
        "\n",
        "Transposing a matrix involves swapping its rows and columns. For example, a $2 \\times 3$ matrix:\n",
        "\n",
        "$$\n",
        "\\mathbf{X}_{2 \\times 3} =\n",
        "\\begin{pmatrix}\n",
        "x_{11} & x_{12} & x_{13} \\\\\n",
        "x_{21} & x_{22} & x_{23}\n",
        "\\end{pmatrix}\n",
        "$${#eq-matrix_2x3}\n",
        "\n",
        "transposes to:\n",
        "\n",
        "$$\n",
        "\\mathbf{X}_{2 \\times 3}^{\\prime} =\n",
        "\\begin{pmatrix}\n",
        "x_{11} & x_{21} \\\\\n",
        "x_{12} & x_{22} \\\\\n",
        "x_{13} & x_{23}\n",
        "\\end{pmatrix}\n",
        "$${#eq-matrix_3x2}\n",
        "\n",
        "where $^{\\prime}$ denotes the transposed matrix. For a column vector $\\mathbf{a}$, transposing and then multiplying by itself, $\\mathbf{a}^{\\prime}\\mathbf{a}$, calculates the sum of squares of its components."
      ],
      "id": "c36d96b4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Example of matrix transposition\n",
        "X_2x3 = np.random.randint(0,100,(2,3))\n",
        "X_transposed = X_2x3.T\n",
        "X_transposed"
      ],
      "id": "2f8b714d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Transposition is often used to conform to the requirements of matrix multiplication, where the number of columns in the first matrix must match the number of rows in the second. If this is not the case, one might transpose the first matrix to facilitate multiplication.\n",
        "\n",
        "# Calculus and matrices\n",
        "\n",
        "Deriving matrices follows similar principles to deriving polynomials [@Cayley1858]. For instance:\n",
        "\n",
        "$$\n",
        "\\frac{d\\left( a^{2} \\sigma^{2} \\right)}{da} = 2a \\sigma^{2}\n",
        "$${#eq-scalar_deriv}\n",
        "\n",
        "applies to scalar variables, and for a matrix $\\Sigma$ and a column vector $\\mathbf{a}$, we have:\n",
        "\n",
        "$$\n",
        "\\frac{d\\left(\\mathbf{a}^{\\prime}{\\Sigma}\\mathbf{a}\\right)}{d\\mathbf{a}^{\\prime}} =2{\\Sigma}\\mathbf{a}\n",
        "$${#eq-matrix_deriv}\n",
        "\n",
        "assuming ${\\Sigma}$ is symmetric. In practical terms, the derivative with respect to `a` here, given some values for `a`, is"
      ],
      "id": "6e9d1f5e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Derivation with matrix and vector\n",
        "a = np.random.randint(0,100,(2,1))\n",
        "Sigma = np.random.randint(0,100,(2,2))\n",
        "\n",
        "# Derivative of a' Sigma a with respect to a\n",
        "derivative = 2 * Sigma @ a\n",
        "derivative"
      ],
      "id": "76b2b109",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can rewrite the matrix formulation in scalar form, to check that the rule is correct. The scalar form of $\\mathbf{a}^{\\prime} {\\Sigma}\\mathbf{a}$ is\n",
        "\n",
        "$$\n",
        "\\mathbf{a}^{\\prime} {\\Sigma} \\mathbf{a} = \\sum_{j=0}^{N} a_j \\left( \\sum_{i=0}^{N} a_i \\sigma_{ij} \\right)\n",
        "$${#eq-matrix_vec_matr_vec_prod}\n",
        "\n",
        "You can verify that \n",
        "\n",
        "$$\n",
        "\\frac{d(\\mathbf{a}^{\\prime} {\\Sigma} \\mathbf{a}) }{d\\mathbf{a}}= 2 [\\sum_{i=0}^{N} a_i \\sigma_{i0}, ..., \\sum_{i=0}^{N} a_i \\sigma_{iN}]\n",
        "$${#eq-matrix_vec_matr_vec_prod_long}\n",
        "\n",
        "\n",
        "\n",
        "# Optimal portfolios with more than one asset\n",
        "\n",
        "\n",
        "We remember from above the previous chapter that with one asset, the optimal portfolio was \n",
        "\n",
        "$$\n",
        "a_{opt}=\\frac{(\\mu -r)}{\\lambda \\sigma^2}\n",
        "$${#eq-opt_port}\n",
        "\n",
        "From this we concluded that:\n",
        "\n",
        "1. The more risk-averse the person is, the less they should invest.\n",
        "2. The larger the expected return of the asset, the more should be invested.\n",
        "3. The greater the risk associated with the asset, represented by $\\sigma^2$, the less should be invested.\n",
        "\n",
        "Now, let us consider the optimal investments if we have more than one asset, as developed by @Markowitz1952.\n",
        "\n",
        "## Optimal Portfolios with Any Number of Assets\n",
        "\n",
        "Let us now assume that the investor in the previous section has a portfolio of $N$ assets, not just one. Their wealth next period, assuming the entire amount is borrowed, is then expressed in matrix notation as:\n",
        "\n",
        "$$\n",
        "W_1 = \\mathbf{a}'\\mathbf{x} - \\mathbf{1}r\n",
        "$${#eq-opt_port}\n",
        "\n",
        "where $\\mathbf{a}$ represents the portfolio weights, $\\mathbf{x}$ represents the returns, and $\\mathbf{1}$ is a column vector of ones, such that $\\mathbf{1}r$ is a column vector of the risk-free interest rate $r$. Recall from earlier that the investor aims to maximize the difference between expected return and variance:\n",
        "\n",
        "$$\n",
        "\\max_{\\mathbf{a}} Z = \\mathbb{E}W_1 - \\lambda \\frac{1}{2} \\operatorname{var}(W_1)  \n",
        "$${#eq-opt_port_max_prob}\n",
        "\n",
        "$\\mathbf{x}$ now is a column vector of many normally distributed variables with different variances and expectations. We denote the expected returns by $\\mu_i$ for asset $i$, and the associated vector of these returns by $\\mathbf{\\mu}$. Given a portfolio $\\mathbf{a}$, the expected return on the portfolio then becomes:\n",
        "\n",
        "$$\n",
        "\\mathbb{E}W_1 = \\mathbf{a}^{\\prime}(\\mathbb{E}\\mathbf{x}-\\mathbf{1}r) = \\mathbf{a}^{\\prime}({\\mu} - \\mathbf{1}r)\n",
        "$${#eq-opt_port_FOC}\n",
        "\n",
        "\n",
        "For the variance, the risk free return $r$ is not relevant, since means are subtracted anyway. We define the covariance matrix, all the combinations of variance and covariance between the stocks as\n",
        "\n",
        "$$\n",
        "\\operatorname{var}W_1 =  \\mathbf{a}^{\\prime}{\\Sigma} \\mathbf{a} = \n",
        "\\mathbf{a}^{\\prime}\n",
        "\\begin{bmatrix}\n",
        "\\sigma_00 & \\sigma_12 & \\cdots & \\sigma_1N \\\\\n",
        "\\sigma_12 & \\sigma_22 & \\cdots & \\vdots \\\\\n",
        "\\vdots & \\vdots & \\ddots & \\vdots \\\\\n",
        "\\sigma_1N & \\cdots & \\cdots & \\sigma_{NN}\n",
        "\\end{bmatrix}\n",
        "\\mathbf{a}\n",
        "$${#eq-covar_matrix}\n",
        "\n",
        "\n",
        "Where $\\sigma_{ij}$ is the covariance between $i$ and $j$, and $\\sigma_i^2$ is the variance of asset $i$. This is the covariance matrix, denoted by the capital sigma, ${\\Sigma}$.\n",
        "\n",
        "When a vector is normally distributed we write it as $\\mathbf{x} \\sim N({\\mu}, {\\Sigma})$.\n",
        "\n",
        "We have now derived expressions for $\\mathbb{E}(W_1)$ and $\\operatorname{var}(W_1)$ using matrix notation. Building on the concepts from the previous lecture, we can now formulate our portfolio optimization problem as:\n",
        "\n",
        "$$\n",
        "\\max_{\\mathbf{a}} Z = \\mathbf{a}^{\\prime}({\\mu} - \\mathbf{1}r) - \\lambda \\frac{1}{2} \\mathbf{a}^{\\prime}{\\Sigma}\\mathbf{a}\n",
        "$${#eq-opt_port_max_problem}\n",
        "\n",
        "Taking the derivative with respect to $\\mathbf{a}^{\\prime}$ yields the $N$ first order conditions:\n",
        "\n",
        "$$\n",
        "\\frac{dZ}{d\\mathbf{a}} = ({\\mu} - \\mathbf{1}r) - \\lambda {\\Sigma a} = 0\n",
        "$${#eq-opt_port_FOC}\n",
        "\n",
        "Hence, in optimum:\n",
        "\n",
        "$$\n",
        "{\\Sigma} \\mathbf{a}= \\frac{1}{\\lambda}({\\mu} - \\mathbf{1}r)\n",
        "$${#eq-opt_port_FOC2}\n",
        "\n",
        "By premultiplying with the inverse of ${\\Sigma}$, we obtain the optimal portfolio:\n",
        "\n",
        "$$\n",
        "\\mathbf{a_{opt}} = \\frac{1}{\\lambda} {\\Sigma}^{-1}({\\mu} - \\mathbf{1}r)\n",
        "$${#eq-opt_port_sol}\n",
        "\n",
        "\n",
        "Note that this formula looks very similar to the formula for an optimal portfolio with only one asset:\n",
        "\n",
        "$$\n",
        "a_{opt} = \\frac{\\mu - r}{\\lambda \\sigma^2}\n",
        "$${#eq-opt_port_scalar}\n",
        "\n",
        "In general, we may draw the same conclusions as in the case of one asset:\n",
        "\n",
        "1. The more risk-averse the person is (large $\\lambda$), the less they should invest.\n",
        "2. The larger the expected return the asset has, the more should be invested.\n",
        "3. The more risk is associated with the asset, the less should be invested.\n",
        "\n",
        "# Empirical example - optimal porfolio and the portfolio front\n",
        "\n",
        "We will now create an optimal portfolio using data from Titlon, and draw the \"portfolio front\" [@Markowitz1952]. The portfolio front are the smallest possible volatility of a set of assets, for all return leves. We use the script feature of Titlon to fetch the data, and storing it in `'data/stocks.df'`"
      ],
      "id": "8507faf4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "import pandas as pd\n",
        "import os\n",
        "#Query script for MySQL client\n",
        "import pymysql\n",
        "con = pymysql.connect(host='titlon.uit.no', \n",
        "                user      = \"user@uit.no\",\n",
        "                password  = \"passwordfromtitlon\",\n",
        "\t\t\t\t\tdatabase='OSE')  \n",
        "crsr=con.cursor()\n",
        "crsr.execute(\"SET SESSION MAX_EXECUTION_TIME=60000;\")\n",
        "crsr.execute(\"\"\"\n",
        "\tSELECT  * FROM `OSE`.`equity` \n",
        "\tWHERE year(`Date`) >= 2016\n",
        "\tORDER BY `Name`,`Date`\n",
        "\"\"\")\n",
        "r=crsr.fetchall()\n",
        "df=pd.DataFrame(list(r), \n",
        "\t\t\tcolumns=[i[0] for i in crsr.description])\n",
        "df\n",
        "\n",
        "\n",
        "\n",
        "#YOU NEED TO BE CONNECTED TO YOUR INSTITUTION VIA VPN,\n",
        "# OR BE AT THE INSTITUTION, FOR THIS CODE TO WORK\n",
        "\n",
        "os.makedirs('output', exist_ok=True)\n",
        "pd.to_pickle(df,'data/stocks.df')"
      ],
      "id": "4924384f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We now reload the data, and pick the four stocks   \n",
        "1. has been traded at the first and last day of the sample\n",
        "2. that are most traded (sorted on sum of `Turnover`)\n",
        "\n",
        "\n",
        "We can obtain that with this code:"
      ],
      "id": "1bed9d37"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import pandas as pd\n",
        "\n",
        "df = pd.read_pickle('data/stocks.df')\n",
        "# Defining annual risk free rate. \n",
        "rf = df['NOWA_DayLnrate'].mean()*7\n",
        "\n",
        "# Identifying the ISINs with dates both at the beginning\n",
        "# and the end of the data set\n",
        "isin_with_first_date = (\n",
        "\tdf[df['Date'] == df['Date'].min()]['ISIN'].unique()\n",
        "\t)\n",
        "isin_with_last_date = (\n",
        "\tdf[df['Date'] == df['Date'].max()]['ISIN'].unique()\n",
        "\t)\n",
        "\n",
        "valid_isins = (\n",
        "\tset(isin_with_first_date)\n",
        "\t.intersection(isin_with_last_date)\n",
        "\t)\n",
        "\n",
        "\n",
        "df = df[df['ISIN'].isin(valid_isins)]\n",
        "\n",
        "# creating a new column - the combination of Name and ISIN\n",
        "df['Name (ISIN)'] = (\n",
        "\tdf['Name'].str.upper().str.strip() + '(' + df['ISIN'] + ')'\n",
        "\t)\n",
        "\n",
        "# keeping only the most traded shares\n",
        "res = (\n",
        "        df.groupby(['Name (ISIN)'])\n",
        "        .agg({'Turnover': 'sum'})\n",
        "        .sort_values(by='Turnover', ascending=False)\n",
        ")\n",
        "df = df.merge(res.head(4), on=['Name (ISIN)'], \n",
        "                                how='inner')\n",
        "res.head(4)"
      ],
      "id": "e6ed3ff0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## The historic mean and covariance matrix\n",
        "We will now calculate the covariance matrix and the mean vector. To begin, we’ll create a function that reformats the data from its long format (where stock prices are listed sequentially in a single column) to a wide format. In this wide format, unique dates will be in the first column, with subsequent columns containing prices for each stock."
      ],
      "id": "5ec386d2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def get_matrix(df, field):\n",
        "\t\"\"\"Converts the df to a matrix df that can \n",
        "\tbe used to calculate the covariance matrix\"\"\"\n",
        "\t\n",
        "\timport pandas as pd\n",
        "\tdf['Date'] = pd.to_datetime(df['Date'])\n",
        "\tdf_unique = df.drop_duplicates(\n",
        "\t\t\t\t\t\tsubset=['Date', 'ISIN'])\n",
        "\n",
        "\tpivot_df = df_unique.pivot(index='Date', \n",
        "\t\t\t\t\t\t\t\tcolumns='Symbol', \n",
        "\t\t\t\t\t\t\t\tvalues=field)\n",
        "\n",
        "\tpivot_df = pivot_df.dropna()\n",
        "\n",
        "\t# Annualized weekly returns\n",
        "\tdf_weekly = pivot_df.resample('W').sum()\n",
        "\n",
        "\treturn df_weekly\n",
        "\n",
        "#X is a matrxi with e\n",
        "X_df = get_matrix(df, 'lnDeltaP') \n",
        "X_df = X_df.sort_index()\n",
        "\n",
        "X_df"
      ],
      "id": "d121fb56",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Wit this data, it is relatively easy to calculate covariance and the means vector"
      ],
      "id": "1b09fe5e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Converting X to a numpy array:\n",
        "X = np.array(X_df)\n",
        "\n",
        "# Calculating the covariance\n",
        "cov_matrix = np.cov(X, rowvar=False)\n",
        "\n",
        "# Calculating the means vector, and reshaping it to a \n",
        "# column vector. \n",
        "\n",
        "means = np.mean(X, axis=0).reshape((X.shape[1],1))"
      ],
      "id": "3fe4662b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Plotting the portfolio front\n",
        "We now turn to portfolio front. The portfolio front represents the volatility of the portfolio with the least variance, for a given portfolio return. Hence, we want a function of portfolio return that represent the minimum variance portfolios.  \n",
        "\n",
        "It turns out that by defining a few simple scalars, there is a reasonably simple expression for the set of minimum variance portfolios. The scalars are:\n",
        "\n",
        "$$\n",
        "A = \\mathbf{1}^{\\prime}{\\Sigma}^{-1}\\mathbf{1}\n",
        "$${#eq-opt_port_A}\n",
        "\n",
        "$$\n",
        "B = \\mathbf{1}^{\\prime}{\\Sigma}^{-1}{\\mu-\\mathbf{1}r}\n",
        "$${#eq-opt_port_B}\n",
        "\n",
        "$$\n",
        "C = {\\mu-\\mathbf{1}r}^{\\prime}{\\Sigma}^{-1}{\\mu-\\mathbf{1}r}\n",
        "$${#eq-opt_port_C}\n",
        "\n",
        "With these definition, the portfolio front, representing all minimum variance portfolios for a given expected return and a total investment of 1, is\n",
        "\n",
        "$$\n",
        "{\\sigma}_{opt} =\\frac{1}{A}+\\frac{ \\left(\\mu_{opt}-\\frac{B}{A}\\right)^2}{C-\\frac{B^2}{A}} \n",
        "$${#eq-opt_port_front}\n",
        "\n",
        "where $\\mu_{opt}={\\mu}^{\\prime}\\mathbf{a}$ \n",
        "\n",
        "This formula automatically ensures that the sum of all the portfolio weights are 1. Now, let us define these variables, and the function. A, B and C in python:"
      ],
      "id": "47a243e7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ones = np.ones((len(means),1))\n",
        "\n",
        "A = (ones.T @ np.linalg.inv(cov_matrix) @ ones)[0][0]\n",
        "\n",
        "B = (ones.T @ np.linalg.inv(cov_matrix) \n",
        "\t\t\t\t\t\t\t\t@ (means-rf))[0][0]\n",
        "\n",
        "C = ((means.T-rf) @ np.linalg.inv(cov_matrix) \n",
        "\t\t\t\t\t\t\t\t@ (means-rf))[0][0]\n",
        "rf"
      ],
      "id": "7805fb96",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The portfolio front function, that returns the volatility associated with the minimum variance portfolio for a given `expected_excess_return` can then be defined as:"
      ],
      "id": "6314afa8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def portfolio_front(expected_excess_return, a, b, c):\n",
        "\tr = expected_excess_return\n",
        "\tminimum_variance = (1/a \n",
        "\t\t\t+ ((r - abs(b)/a)**2) / (c - b**2/a))\n",
        "\tminimum_volatility = minimum_variance**0.5\n",
        "\treturn minimum_volatility"
      ],
      "id": "892bc2a2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With a defined portfolio frontier function, we can now plot the portfolio frontier. To make the weekly returns comparable on an annual scale, we multiply them by a scaling factor, `plot_scale`, set to 52. We can simply multiply the returns, because returns in Titlon are conveniently defined as log returns, calculated as $\\log(x_{t}) - \\log(x_{t-1})$, rather than the typical relative return $\\frac{x_{t} - x_{t-1}}{x_{t-1}}$.\n"
      ],
      "id": "6693f4d2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from matplotlib import pyplot as plt\n",
        "#Creating plot\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "plot_scale = 52\n",
        "MAX_AXIS = 0.005\n",
        "#applying the function\n",
        "rp_values = np.linspace(0, MAX_AXIS-rf, 100)\n",
        "sigma_values = portfolio_front(rp_values, A, B, C)\n",
        "\n",
        "#plotting, after annualizing the weekly data\n",
        "ax.plot(plot_scale**0.5*(sigma_values), \n",
        "\t\t\tplot_scale*(rp_values+rf), \n",
        "\t\t\tlabel='Efficient Frontier')\n",
        "\n",
        "#plot settings:\n",
        "ax.set_xlim([0, np.max(sigma_values*plot_scale**0.5)])\n",
        "ax.set_ylim([0, (np.max(rp_values)+rf)*plot_scale])\n",
        "ax.set_xlabel('Sigma (Risk)')\n",
        "ax.set_ylabel('Rp (Return)')\n",
        "ax.set_title('Efficient Frontier')\n",
        "ax.legend()"
      ],
      "id": "ffa50b04",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "A key advantage of using log returns is that they account for symmetry in gains and losses. For example, with relative returns, a 10% gain followed by a 10% loss results in a net loss of 1%. However, with log returns, a 10% gain and a 10% loss precisely offset each other, leaving you with no net change from the starting point.\n",
        "\n",
        "## Adding the optimal portfolio to the chart\n",
        "Let us now add the point for the optimal portfolio. The optimal portfolio is \n",
        "\n",
        "$$\n",
        "\\mathbf{a}_{opt} = \\frac{1}{\\lambda}{\\Sigma}^{-1}({\\mu} - \\mathbf{1}r)\n",
        "$${#eq-opt_port_sol2}\n",
        "\n",
        "The total cost (sum) of this portfolio is\n",
        "$$\n",
        "\\mathbf{1}^{\\prime}\\mathbf{a}_{opt} = \\frac{1}{\\lambda} \\mathbf{1}^{\\prime}{\\Sigma}^{-1}({\\mu} - \\mathbf{1}r) = B\n",
        "$${#eq-sum_eq}\n",
        "\n",
        "Where the last equality follows from Equation \\ref{eq:B}. The normalized optimal portfolio is then\n",
        "\n",
        "$$\n",
        "\\mathbf{a}_{norm}  = \\frac{ {\\Sigma}^{-1}({\\mu} - \\mathbf{1}r) }\n",
        "{ \\mathbf{1}^{\\prime}{\\Sigma}^{-1}({\\mu} - \\mathbf{1}r)} = \\frac{ 1 }\n",
        "{B}{\\Sigma}^{-1}({\\mu} - \\mathbf{1}r)\n",
        "$${#eq-norm_opt}\n",
        "\n",
        "The expected return of the optimal portfolio on the frontier, is then \n",
        "\n",
        "$$\n",
        "\\mu_{port}=({\\mu} - \\mathbf{1}r)^{\\prime}\\mathbf{a_{norm}}  = \\frac{({\\mu} - \\mathbf{1}r)^{\\prime}{\\Sigma}^{-1}({\\mu} - \\mathbf{1}r)}{ \\mathbf{1}^{\\prime}{\\Sigma}^{-1}({\\mu} - \\mathbf{1}r)} \n",
        "$${#eq-opt_port_sol_exp_ret}\n",
        "\n",
        "Which is simply, according to the previous definitions of B and C:\n",
        "$$\n",
        "\\mu_{port}=\\frac{C}{B}\n",
        "$${#eq-opt_port_sol_exp_ret_simple}\n",
        "\n",
        "Let us add that to the plot"
      ],
      "id": "897a2ccb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Calculating the tangency point of the normalized \n",
        "# optimal portfolio\n",
        "tangency_sigma =  portfolio_front(C/B, A, B, C)\n",
        "\n",
        "#plotting it, after annualizing the weekly data\n",
        "ax.plot(plot_scale**0.5*tangency_sigma, \n",
        "\t\t\t\t\tplot_scale*(C/B + rf), \n",
        "\t\t\t\t\t'ro',label='Tangency Point')\n",
        "ax.legend()\n",
        "fig"
      ],
      "id": "9aef10b4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Adding the tangency line\n",
        "Let us now draw a tangency line from the risk free interest rate `rf` to the optimal portfolio point. The slope will be the Sharp-ratio [@Sharpe1964]\n",
        "\n",
        "$$\n",
        "S=\\frac{C/B}{f(C/B)}\n",
        "$${#eq-opt_port_sol_sharpe}\n",
        "\n",
        "where $f(C/B)$ is the portfolio front function `portfolio_front(C/B, A, B, C)` at `C/B`"
      ],
      "id": "fb14077b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-cml\n",
        "#| fig-cap: Capital Market Line and Portfolio Front\n",
        "sigma_range = np.linspace(0, np.max(sigma_values), 100)\n",
        "\n",
        "# Plotting the portfolio front, after annualizing the \n",
        "# weekly data\n",
        "ax.plot(plot_scale**0.5*sigma_range, plot_scale*(rf \n",
        "\t\t\t\t+ sigma_range*(C/B)/tangency_sigma), \n",
        "\t\t\t\tcolor='r', linestyle='--', \n",
        "\t\t\t\tlabel='Capital Market Line')\n",
        "\n",
        "ax.legend()\n",
        "\n",
        "fig"
      ],
      "id": "fig-cml",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "@fig-cml illustrates the concept of the separation theorem as described by @Tobin1958. Once the optimal portfolio is identified, it can be combined with a risk-free asset, allowing the investor to choose any point on the red capital allocation line.\n",
        "\n",
        "The optimal portfolio represents the tangency point of this line with the portfolio front. Investors cannot select any asset above or to the left of the portfolio front, as such positions are not feasible. Any point within the front is considered inefficient, as better trade-offs between risk and return are attainable. The capital allocation line, therefore, must begin at the risk-free return and have the steepest possible slope while touching the portfolio front, as depicted in @fig-cml.\n",
        "\n",
        "\n",
        "## Adding the stocks spanning the portfolio front\n",
        "It is interesting to check where the original stocks that span the front, are in the picture. Let us add the cooridnates of these. We first calcualate their mean and standard devaition, and then plot them."
      ],
      "id": "d82ad919"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "expected = X_df.mean()*52\n",
        "std = X_df.std()*52**0.5\n",
        "\n",
        "\n",
        "for series in expected.index:\n",
        "\t\tax.scatter(std[series], expected[series], label=series)\n",
        "\t\tax.text(std[series], expected[series], series, fontsize=8, ha='right', va='bottom')\n",
        "\n",
        "fig"
      ],
      "id": "a51e800f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## The optimal portfolio\n",
        "Finally, we might want to evaluate the actual amounts that we should invest in each company, if we wanted to invest in the optimal portfolio. The actual portfolio, normalized to sum to one, is as previously implied\n",
        "\n",
        "$$\n",
        "\\mathbf{a}_{norm}  = \\frac{1}\n",
        "{B} {\\Sigma}^{-1}({\\mu} - \\mathbf{1}r) \n",
        "$${#eq-opt_port_sol_norm2}\n",
        "\n",
        "where $B$ is the sum of the optimal portfolio, as previously defined in \\ref{eq:B}\n",
        "\n",
        "We can code that as"
      ],
      "id": "2b05afc9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#Calculating the normalized optimal portfolio\n",
        "opt_port = np.linalg.inv(cov_matrix) @ (means-rf)/B\n",
        "\n",
        "#Calculating the returns of the optimal portfolio:\n",
        "X_df['Optimal'] = X @ opt_port\n",
        "\n",
        "#Saving the dataframe for later use:\n",
        "pd.to_pickle(X_df, 'data/X.df')\n",
        "\n",
        "# inserting the portfolio into a data frame for display\n",
        "d = {}\n",
        "for i in range(len(opt_port)):\n",
        "\td[X_df.columns[i]] = [\n",
        "\t\t\tf\"{np.round(opt_port[i][0]*100,0)}%\"\n",
        "\t\t]\n",
        "\n",
        "print(\"Hence the optimal portfolio in this case is\")\n",
        "pd.DataFrame(d)"
      ],
      "id": "b9e4f6b6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "***Coding Challenges:***\n",
        "\n",
        "- **Challenge 1**: Obtain a three or four time series with asset returns, and calculate the variance-covariance matrix and the means\n",
        "\n",
        "- **Challenge 2**: Use your calculated covariance matrix and means, and the code provided above, to draw a portfolio front. \n",
        "\n",
        "- **Challenge 3**: Use the same information to plot the points of each portfolio in the same chart.\n",
        "\n",
        "- **Challenge 4**: Calculate the optimal portfolio and place it in the chart, together with the capital market line  \n",
        "\n",
        "\n",
        "# Literature\n",
        "::: {#refs}\n",
        ":::"
      ],
      "id": "858bcd12"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\esi000\\AppData\\Local\\Programs\\Python\\Python313\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}